# -*- coding: utf-8 -*-
"""
Created on Sun Oct  4 17:43:51 2015

@author: gibon
"""

from sympy import divisor_sigma as sigma
from sympy import sieve, factorint

"""
Maybe some help here
http://math.stackexchange.com/questions/363842/how-are-10-20-digit-multiperfect-and-hemiperfect-numbers-efficiently-computed

You can use the fact that the sum of divisors function is multiplicative.
We have that σ(p**n)=(p**n+1−1)/(p−1) for p prime and
σ(rs)=σ(r)σ(s) for r coprime to s. So you look for combinations
of prime powers that cancel off the denominators. You need lots of prime
factors, which therefore need to be pretty small, so you can ignore a lot of
numbers.

Check http://www.numericana.com/answer/numbers.htm#multiperfect
"""

# From OEIS, A159907

l = sorted([2,24,4320,4680,26208,8910720,17428320,20427264,
 91963648,197064960,8583644160,10200236032,
 21857648640,57575890944,57629644800,206166804480,
 17116004505600,1416963251404800,15338300494970880,88898072401645056,
 301183421949935616, 9083288595228991885541376, 22290964134962716779872256,
 230361837156847526055247872, 3551746147589248994873004392448,
 8716209461184471402733217906688, 90076051101488582786918337478656,
 275517471462331149989751161880576, 8319263987369391948455878608398843904,
 20415999472827819113761327282781159424,
 3081634264657305632386843579602306072576,
 93050102500349677040144591462063024482811904,
 228350830852095014942603539620449439316967424,
 6275163455171297280, 200286975596707184640, 215594611071909888000,
 5997579964837140234240, 39887491844324122951680, 189478877946949032837120,
 464993138593758319902720, 4577250484712348791603200,
 314220801442981320248524800, 14048146725436554258960875520,
 20270811496597107858493931520, 81703797123392614369698250752,
 612078178502919543930287114158080, 939834592031480161274941547741184,
 1502078523847443989273473166868480, 2306413471743588373372911017263104,
 157127060125322787706213898932715520, 954799029953763034837845432097308672,
 2343137147924117580221226004651180032,
 11528505172715763556107234109992568639979520000, 75462255348480000,
 6219051710415667200, 14031414189615513600, 352444116692828160000,
 835095457414213632000, 59485231752222033838080, 64031599488357236736000,
 564178061132326319357952000, 1208818605469519237939200000,
 1384528609279142174195712000, 3101020675856435565821952000,
 3333576337140514195596902400, 170974031122008628879954060917200710847692800,
 1893010442758976546037991125738431754692198400,
 54361481238923605327597493185154939181072384000,
 251754911117461891901909334695193204308626636800,
 1896011572527867940620729403187025422081379532800,
 1949479690331253229796013159150974699442693734400])

test = [(sigma(k,-1),factorint(k)) for k in l]

ub = 1000000

sieve.extend(300) # assume it's enough
primes = list(sieve._list)

k_list = []
k = 2

k_list = [k for k in range(2,ub,2) if 2 * sigma(k,-1) % 2 == 1]

k_list3 = []

"""
Sieve method for multiperfect numbers
from http://programmingpraxis.com/2015/09/25/multiply-perfect-numbers/
"""

def multiply_perfect(limit=1000000):
    divisor_sum = [0]*limit
    for n in range(1, limit):
        for k in range(n, limit, n):
            divisor_sum[k] += n
        if divisor_sum[n] % n == 0:
            print(n, divisor_sum[n], divisor_sum[n]//n)

multiply_perfect(10**9)



